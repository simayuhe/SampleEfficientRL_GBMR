# SampleEfficientRL_GBMR
2021年4月10日 康永欣

基本实验整理，方便重新部署到不同的服务器上。

两个主要环境：MiniMaze 和 Atari

MiniMaze 主要用来理清思路，Atari 用来作为结果展示用

## MiniMaze



## Atari

概况：NEC是参考方案。GQ, GBMR 是我们的基础实验，分为两个版本：
+ 一个是对每个动作构图，这个虽然在理论上有缺陷，但是速度更快，似乎也有一些前期效果；
+ 另一个是对整体构图，这个目前认为是正确的，但是速度要慢很多，效果还有待验证。

可用的游戏：Alien-v4, MsPacman-v4, Hero-v4, BankHeist-v4,Amidar-v4, MR-V4，Bowling, Frostbite, Pong-v4 说明有效果和没有效果的原因

参数：

NEC中参数：
+ 编码所用模型 model , 大家公用一个方便比较，不调整
+ 随机种子，可以尝试多个，然后做平均
+ training_iters 40million， 资源够用的情况下就用这个，然后不断截取中间结果，对比调整
+ learning rate/batch size/replay memory size/learning step, 保证大家都一样，方便调整
+ memory_size 这个要和图中的相同，可以考虑100 000 
+ num_neighbours 50  可以尝试更大，但更小肯定是没有效果的
+ n_step 在正常情况下是要用的，但是在稀疏奖励的环境中似乎并不那么好用
+ discount/epsilon 的设置是一样的

GQv1中多出来的参数：
+ dist_th 用来判断什么时候新建状态，在不同的游戏中会有不同的表现，但是整体都差不多，因为是对特征进行编码之后的
    NEC中没有这个替换的过程，而是直接满了再加
+ 用GQ把各个游戏的dist_th 调节好，后面就不进行改动了
+ 这个东西是一种权衡，dist_th 小了，节点很快就会充满整个空间，速度就慢了下来


GQV2 是用一幅图构建的，动作之间不做区分存储

统一各个算法中的内存
GBMR 多了一个expert memory size

GBMR 又多了一个关键点选择的函数
重构的时机也是需要进行选择的，我们是每隔多长时间重构一次
如果我们对编码的区分度过大，那么就很难有相同的状态出现， 所以除了Pong0.1之外所有的距离都是1


基本部署：
0410
9个游戏，每个对应5种算法 
Alien-v4, MsPacman-v4, Hero-v4, BankHeist-v4,Amidar-v4, MontezumaRevenge-v4，Bowling-v4, Frostbite-v4, Pong-v4


现在出现的问题是GBMR2的结果并不动，要找到原因，先对比一下，如果我们用的是GBMR_V1的Q值改进版本会不会有提升





# 对应到论文中的内容

有四部分： 
Maze 游戏解释GBMR的流程；
Atari 游戏中的消融实验；
Atari 游戏中的对比实验；
Atari 游戏中的中间结果解释；


这些东西要用统一的评价框架

## Maze 中实现基本流程
因为不需要设计编码器，所以就直接建图
因为不需要查近邻，所以直接读状态

1. 要得到每一步的记忆图可视化，抽象图可视化，重构边权的可视化
2. 要对比图表示的Q和普通的Q之间的关系结果
3. 要对比两个以上的重构方案，并将结果与Q learning 对比

## Atari 消融

+ 编码模块先用DQN实现，设计多个选项的接口

1. 多个近邻的对比，10 50 100 
2. 关键点选取：出度入度，交叉节点，聚类中心
3. 路径评估： 累积奖励，最短路径，状态多样性

## Atari 对比

1. 图结构和表结构之间的差异有多大 （GQ的代码做一个通用的表示即可）
2. 表+ 关键点重采样（NEC中重新采样点来训练网络结构是否合理呢） vs 图重构
3. DQN（para）, PER, NEC(semi-para), ERLAM(semi-para), GBMR(non-para + para)
4. 与world model

## Atari 的解释
non-para 更具可解释性，更有可能成为RL 的 一个新的方向，如何看待可解释性
1. 联想记忆，我们要看到训练中期的时候，每次查到的内容是什么？每次有一个输入状态，从Graph 中查出来的是多个不同关卡中的可能状态。
2. 重构的过程如何形象地表示出来？我们重构的不仅仅是路径，还有边权，如何可视化出来
3. 每新见到一个样本都对多个区域的信号有更新，每做一次决策都和多个区域信息有关，这个过程是另外一个能够加速学习的地方，我们可以在实验中进行验证，也就是说把邻居数目调小，之后观察结果，这是自身能力的一种体现，也是sample efficiency 的一个重要原因